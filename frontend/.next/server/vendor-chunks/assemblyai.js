"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/assemblyai";
exports.ids = ["vendor-chunks/assemblyai"];
exports.modules = {

/***/ "(ssr)/./node_modules/assemblyai/dist/node.mjs":
/*!***********************************************!*\
  !*** ./node_modules/assemblyai/dist/node.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssemblyAI: () => (/* binding */ AssemblyAI),\n/* harmony export */   FileService: () => (/* binding */ FileService),\n/* harmony export */   LemurService: () => (/* binding */ LemurService),\n/* harmony export */   RealtimeService: () => (/* binding */ RealtimeService),\n/* harmony export */   RealtimeServiceFactory: () => (/* binding */ RealtimeServiceFactory),\n/* harmony export */   RealtimeTranscriber: () => (/* binding */ RealtimeTranscriber),\n/* harmony export */   RealtimeTranscriberFactory: () => (/* binding */ RealtimeTranscriberFactory),\n/* harmony export */   TranscriptService: () => (/* binding */ TranscriptService)\n/* harmony export */ });\n/* harmony import */ var stream_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream/web */ \"stream/web\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ws */ \"(ssr)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stream */ \"stream\");\n\n\n\n\n\nconst DEFAULT_FETCH_INIT = {\n    cache: \"no-store\",\n};\n\nconst buildUserAgent = (userAgent) => defaultUserAgentString +\n    (userAgent === false\n        ? \"\"\n        : \" AssemblyAI/1.0 (\" +\n            Object.entries({ ...defaultUserAgent, ...userAgent })\n                .map(([key, item]) => item ? `${key}=${item.name}/${item.version}` : \"\")\n                .join(\" \") +\n            \")\");\nlet defaultUserAgentString = \"\";\nif (typeof navigator !== \"undefined\" && navigator.userAgent) {\n    defaultUserAgentString += navigator.userAgent;\n}\nconst defaultUserAgent = {\n    sdk: { name: \"JavaScript\", version: \"4.7.0\" },\n};\nif (typeof process !== \"undefined\") {\n    if (process.versions.node && defaultUserAgentString.indexOf(\"Node\") === -1) {\n        defaultUserAgent.runtime_env = {\n            name: \"Node\",\n            version: process.versions.node,\n        };\n    }\n    if (process.versions.bun && defaultUserAgentString.indexOf(\"Bun\") === -1) {\n        defaultUserAgent.runtime_env = {\n            name: \"Bun\",\n            version: process.versions.bun,\n        };\n    }\n}\nif (typeof Deno !== \"undefined\") {\n    if (process.versions.bun && defaultUserAgentString.indexOf(\"Deno\") === -1) {\n        defaultUserAgent.runtime_env = { name: \"Deno\", version: Deno.version.deno };\n    }\n}\n\n/**\n * Base class for services that communicate with the API.\n */\nclass BaseService {\n    /**\n     * Create a new service.\n     * @param params - The parameters to use for the service.\n     */\n    constructor(params) {\n        this.params = params;\n        if (params.userAgent === false) {\n            this.userAgent = undefined;\n        }\n        else {\n            this.userAgent = buildUserAgent(params.userAgent || {});\n        }\n    }\n    async fetch(input, init) {\n        init = { ...DEFAULT_FETCH_INIT, ...init };\n        let headers = {\n            Authorization: this.params.apiKey,\n            \"Content-Type\": \"application/json\",\n        };\n        if (DEFAULT_FETCH_INIT?.headers)\n            headers = { ...headers, ...DEFAULT_FETCH_INIT.headers };\n        if (init?.headers)\n            headers = { ...headers, ...init.headers };\n        if (this.userAgent) {\n            headers[\"User-Agent\"] = this.userAgent;\n            // chromium browsers have a bug where the user agent can't be modified\n            if (typeof window !== \"undefined\" && \"chrome\" in window) {\n                headers[\"AssemblyAI-Agent\"] =\n                    this.userAgent;\n            }\n        }\n        init.headers = headers;\n        if (!input.startsWith(\"http\"))\n            input = this.params.baseUrl + input;\n        const response = await fetch(input, init);\n        if (response.status >= 400) {\n            let json;\n            const text = await response.text();\n            if (text) {\n                try {\n                    json = JSON.parse(text);\n                }\n                catch {\n                    /* empty */\n                }\n                if (json?.error)\n                    throw new Error(json.error);\n                throw new Error(text);\n            }\n            throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async fetchJson(input, init) {\n        const response = await this.fetch(input, init);\n        return response.json();\n    }\n}\n\nclass LemurService extends BaseService {\n    summary(params) {\n        return this.fetchJson(\"/lemur/v3/generate/summary\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n    }\n    questionAnswer(params) {\n        return this.fetchJson(\"/lemur/v3/generate/question-answer\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n    }\n    actionItems(params) {\n        return this.fetchJson(\"/lemur/v3/generate/action-items\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n    }\n    task(params) {\n        return this.fetchJson(\"/lemur/v3/generate/task\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n    }\n    getResponse(id) {\n        return this.fetchJson(`/lemur/v3/${id}`);\n    }\n    /**\n     * Delete the data for a previously submitted LeMUR request.\n     * @param id - ID of the LeMUR request\n     */\n    purgeRequestData(id) {\n        return this.fetchJson(`/lemur/v3/${id}`, {\n            method: \"DELETE\",\n        });\n    }\n}\n\nconst factory = (url, params) => new ws__WEBPACK_IMPORTED_MODULE_1__[\"default\"](url, params);\n\nconst RealtimeErrorType = {\n    BadSampleRate: 4000,\n    AuthFailed: 4001,\n    /**\n     * @deprecated Use InsufficientFunds or FreeTierUser instead\n     */\n    InsufficientFundsOrFreeAccount: 4002,\n    InsufficientFunds: 4002,\n    FreeTierUser: 4003,\n    NonexistentSessionId: 4004,\n    SessionExpired: 4008,\n    ClosedSession: 4010,\n    RateLimited: 4029,\n    UniqueSessionViolation: 4030,\n    SessionTimeout: 4031,\n    AudioTooShort: 4032,\n    AudioTooLong: 4033,\n    AudioTooSmallToTranscode: 4034,\n    /**\n     * @deprecated Don't use\n     */\n    BadJson: 4100,\n    BadSchema: 4101,\n    TooManyStreams: 4102,\n    Reconnected: 4103,\n    /**\n     * @deprecated Don't use\n     */\n    ReconnectAttemptsExhausted: 1013,\n    WordBoostParameterParsingFailed: 4104,\n};\nconst RealtimeErrorMessages = {\n    [RealtimeErrorType.BadSampleRate]: \"Sample rate must be a positive integer\",\n    [RealtimeErrorType.AuthFailed]: \"Not Authorized\",\n    [RealtimeErrorType.InsufficientFunds]: \"Insufficient funds\",\n    [RealtimeErrorType.FreeTierUser]: \"This feature is paid-only and requires you to add a credit card. Please visit https://app.assemblyai.com/ to add a credit card to your account.\",\n    [RealtimeErrorType.NonexistentSessionId]: \"Session ID does not exist\",\n    [RealtimeErrorType.SessionExpired]: \"Session has expired\",\n    [RealtimeErrorType.ClosedSession]: \"Session is closed\",\n    [RealtimeErrorType.RateLimited]: \"Rate limited\",\n    [RealtimeErrorType.UniqueSessionViolation]: \"Unique session violation\",\n    [RealtimeErrorType.SessionTimeout]: \"Session Timeout\",\n    [RealtimeErrorType.AudioTooShort]: \"Audio too short\",\n    [RealtimeErrorType.AudioTooLong]: \"Audio too long\",\n    [RealtimeErrorType.AudioTooSmallToTranscode]: \"Audio too small to transcode\",\n    [RealtimeErrorType.BadJson]: \"Bad JSON\",\n    [RealtimeErrorType.BadSchema]: \"Bad schema\",\n    [RealtimeErrorType.TooManyStreams]: \"Too many streams\",\n    [RealtimeErrorType.Reconnected]: \"This session has been reconnected. This WebSocket is no longer valid.\",\n    [RealtimeErrorType.ReconnectAttemptsExhausted]: \"Reconnect attempts exhausted\",\n    [RealtimeErrorType.WordBoostParameterParsingFailed]: \"Could not parse word boost parameter\",\n};\nclass RealtimeError extends Error {\n}\n\nconst defaultRealtimeUrl = \"wss://api.assemblyai.com/v2/realtime/ws\";\nconst forceEndOfUtteranceMessage = `{\"force_end_utterance\":true}`;\nconst terminateSessionMessage = `{\"terminate_session\":true}`;\n/**\n * RealtimeTranscriber connects to the Streaming Speech-to-Text API and lets you transcribe audio in real-time.\n */\nclass RealtimeTranscriber {\n    /**\n     * Create a new RealtimeTranscriber.\n     * @param params - Parameters to configure the RealtimeTranscriber\n     */\n    constructor(params) {\n        this.listeners = {};\n        this.realtimeUrl = params.realtimeUrl ?? defaultRealtimeUrl;\n        this.sampleRate = params.sampleRate ?? 16_000;\n        this.wordBoost = params.wordBoost;\n        this.encoding = params.encoding;\n        this.endUtteranceSilenceThreshold = params.endUtteranceSilenceThreshold;\n        this.disablePartialTranscripts = params.disablePartialTranscripts;\n        if (\"token\" in params && params.token)\n            this.token = params.token;\n        if (\"apiKey\" in params && params.apiKey)\n            this.apiKey = params.apiKey;\n        if (!(this.token || this.apiKey)) {\n            throw new Error(\"API key or temporary token is required.\");\n        }\n    }\n    connectionUrl() {\n        const url = new URL(this.realtimeUrl);\n        if (url.protocol !== \"wss:\") {\n            throw new Error(\"Invalid protocol, must be wss\");\n        }\n        const searchParams = new URLSearchParams();\n        if (this.token) {\n            searchParams.set(\"token\", this.token);\n        }\n        searchParams.set(\"sample_rate\", this.sampleRate.toString());\n        if (this.wordBoost && this.wordBoost.length > 0) {\n            searchParams.set(\"word_boost\", JSON.stringify(this.wordBoost));\n        }\n        if (this.encoding) {\n            searchParams.set(\"encoding\", this.encoding);\n        }\n        searchParams.set(\"enable_extra_session_information\", \"true\");\n        if (this.disablePartialTranscripts) {\n            searchParams.set(\"disable_partial_transcripts\", this.disablePartialTranscripts.toString());\n        }\n        url.search = searchParams.toString();\n        return url;\n    }\n    /**\n     * Add a listener for an event.\n     * @param event - The event to listen for.\n     * @param listener - The function to call when the event is emitted.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    on(event, listener) {\n        this.listeners[event] = listener;\n    }\n    /**\n     * Connect to the server and begin a new session.\n     * @returns A promise that resolves when the connection is established and the session begins.\n     */\n    connect() {\n        return new Promise((resolve) => {\n            if (this.socket) {\n                throw new Error(\"Already connected\");\n            }\n            const url = this.connectionUrl();\n            if (this.token) {\n                this.socket = factory(url.toString());\n            }\n            else {\n                this.socket = factory(url.toString(), {\n                    headers: { Authorization: this.apiKey },\n                });\n            }\n            this.socket.binaryType = \"arraybuffer\";\n            this.socket.onopen = () => {\n                if (this.endUtteranceSilenceThreshold === undefined ||\n                    this.endUtteranceSilenceThreshold === null) {\n                    return;\n                }\n                this.configureEndUtteranceSilenceThreshold(this.endUtteranceSilenceThreshold);\n            };\n            this.socket.onclose = ({ code, reason }) => {\n                if (!reason) {\n                    if (code in RealtimeErrorMessages) {\n                        reason = RealtimeErrorMessages[code];\n                    }\n                }\n                this.listeners.close?.(code, reason);\n            };\n            this.socket.onerror = (event) => {\n                if (event.error)\n                    this.listeners.error?.(event.error);\n                else\n                    this.listeners.error?.(new Error(event.message));\n            };\n            this.socket.onmessage = ({ data }) => {\n                const message = JSON.parse(data.toString());\n                if (\"error\" in message) {\n                    this.listeners.error?.(new RealtimeError(message.error));\n                    return;\n                }\n                switch (message.message_type) {\n                    case \"SessionBegins\": {\n                        const openObject = {\n                            sessionId: message.session_id,\n                            expiresAt: new Date(message.expires_at),\n                        };\n                        resolve(openObject);\n                        this.listeners.open?.(openObject);\n                        break;\n                    }\n                    case \"PartialTranscript\": {\n                        // message.created is actually a string when coming from the socket\n                        message.created = new Date(message.created);\n                        this.listeners.transcript?.(message);\n                        this.listeners[\"transcript.partial\"]?.(message);\n                        break;\n                    }\n                    case \"FinalTranscript\": {\n                        // message.created is actually a string when coming from the socket\n                        message.created = new Date(message.created);\n                        this.listeners.transcript?.(message);\n                        this.listeners[\"transcript.final\"]?.(message);\n                        break;\n                    }\n                    case \"SessionInformation\": {\n                        this.listeners.session_information?.(message);\n                        break;\n                    }\n                    case \"SessionTerminated\": {\n                        this.sessionTerminatedResolve?.();\n                        break;\n                    }\n                }\n            };\n        });\n    }\n    /**\n     * Send audio data to the server.\n     * @param audio - The audio data to send to the server.\n     */\n    sendAudio(audio) {\n        this.send(audio);\n    }\n    /**\n     * Create a writable stream that can be used to send audio data to the server.\n     * @returns A writable stream that can be used to send audio data to the server.\n     */\n    stream() {\n        return new stream_web__WEBPACK_IMPORTED_MODULE_0__.WritableStream({\n            write: (chunk) => {\n                this.sendAudio(chunk);\n            },\n        });\n    }\n    /**\n     * Manually end an utterance\n     */\n    forceEndUtterance() {\n        this.send(forceEndOfUtteranceMessage);\n    }\n    /**\n     * Configure the threshold for how long to wait before ending an utterance. Default is 700ms.\n     * @param threshold - The duration of the end utterance silence threshold in milliseconds.\n     * This value must be an integer between 0 and 20_000.\n     */\n    configureEndUtteranceSilenceThreshold(threshold) {\n        this.send(`{\"end_utterance_silence_threshold\":${threshold}}`);\n    }\n    send(data) {\n        if (!this.socket || this.socket.readyState !== this.socket.OPEN) {\n            throw new Error(\"Socket is not open for communication\");\n        }\n        this.socket.send(data);\n    }\n    /**\n     * Close the connection to the server.\n     * @param waitForSessionTermination - If true, the method will wait for the session to be terminated before closing the connection.\n     * While waiting for the session to be terminated, you will receive the final transcript and session information.\n     */\n    async close(waitForSessionTermination = true) {\n        if (this.socket) {\n            if (this.socket.readyState === this.socket.OPEN) {\n                if (waitForSessionTermination) {\n                    const sessionTerminatedPromise = new Promise((resolve) => {\n                        this.sessionTerminatedResolve = resolve;\n                    });\n                    this.socket.send(terminateSessionMessage);\n                    await sessionTerminatedPromise;\n                }\n                else {\n                    this.socket.send(terminateSessionMessage);\n                }\n            }\n            if (this.socket?.removeAllListeners)\n                this.socket.removeAllListeners();\n            this.socket.close();\n        }\n        this.listeners = {};\n        this.socket = undefined;\n    }\n}\n/**\n * @deprecated Use RealtimeTranscriber instead\n */\nclass RealtimeService extends RealtimeTranscriber {\n}\n\nclass RealtimeTranscriberFactory extends BaseService {\n    constructor(params) {\n        super(params);\n        this.rtFactoryParams = params;\n    }\n    /**\n     * @deprecated Use transcriber(...) instead\n     */\n    createService(params) {\n        return this.transcriber(params);\n    }\n    transcriber(params) {\n        const serviceParams = { ...params };\n        if (!serviceParams.token && !serviceParams.apiKey) {\n            serviceParams.apiKey = this.rtFactoryParams.apiKey;\n        }\n        return new RealtimeTranscriber(serviceParams);\n    }\n    async createTemporaryToken(params) {\n        const data = await this.fetchJson(\"/v2/realtime/token\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n        return data.token;\n    }\n}\n/**\n * @deprecated Use RealtimeTranscriberFactory instead\n */\nclass RealtimeServiceFactory extends RealtimeTranscriberFactory {\n}\n\nfunction getPath(path) {\n    if (path.startsWith(\"http\"))\n        return null;\n    if (path.startsWith(\"https\"))\n        return null;\n    if (path.startsWith(\"data:\"))\n        return null;\n    if (path.startsWith(\"file://\"))\n        return path.substring(7);\n    if (path.startsWith(\"file:\"))\n        return path.substring(5);\n    return path;\n}\n\nclass TranscriptService extends BaseService {\n    constructor(params, files) {\n        super(params);\n        this.files = files;\n    }\n    /**\n     * Transcribe an audio file. This will create a transcript and wait until the transcript status is \"completed\" or \"error\".\n     * @param params - The parameters to transcribe an audio file.\n     * @param options - The options to transcribe an audio file.\n     * @returns A promise that resolves to the transcript. The transcript status is \"completed\" or \"error\".\n     */\n    async transcribe(params, options) {\n        const transcript = await this.submit(params);\n        return await this.waitUntilReady(transcript.id, options);\n    }\n    /**\n     * Submits a transcription job for an audio file. This will not wait until the transcript status is \"completed\" or \"error\".\n     * @param params - The parameters to start the transcription of an audio file.\n     * @returns A promise that resolves to the queued transcript.\n     */\n    async submit(params) {\n        let audioUrl;\n        let transcriptParams = undefined;\n        if (\"audio\" in params) {\n            const { audio, ...audioTranscriptParams } = params;\n            if (typeof audio === \"string\") {\n                const path = getPath(audio);\n                if (path !== null) {\n                    // audio is local path, upload local file\n                    audioUrl = await this.files.upload(path);\n                }\n                else {\n                    if (audio.startsWith(\"data:\")) {\n                        audioUrl = await this.files.upload(audio);\n                    }\n                    else {\n                        // audio is not a local path, and not a data-URI, assume it's a normal URL\n                        audioUrl = audio;\n                    }\n                }\n            }\n            else {\n                // audio is of uploadable type\n                audioUrl = await this.files.upload(audio);\n            }\n            transcriptParams = { ...audioTranscriptParams, audio_url: audioUrl };\n        }\n        else {\n            transcriptParams = params;\n        }\n        const data = await this.fetchJson(\"/v2/transcript\", {\n            method: \"POST\",\n            body: JSON.stringify(transcriptParams),\n        });\n        return data;\n    }\n    /**\n     * Create a transcript.\n     * @param params - The parameters to create a transcript.\n     * @param options - The options used for creating the new transcript.\n     * @returns A promise that resolves to the transcript.\n     * @deprecated Use `transcribe` instead to transcribe a audio file that includes polling, or `submit` to transcribe a audio file without polling.\n     */\n    async create(params, options) {\n        const path = getPath(params.audio_url);\n        if (path !== null) {\n            const uploadUrl = await this.files.upload(path);\n            params.audio_url = uploadUrl;\n        }\n        const data = await this.fetchJson(\"/v2/transcript\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n        if (options?.poll ?? true) {\n            return await this.waitUntilReady(data.id, options);\n        }\n        return data;\n    }\n    /**\n     * Wait until the transcript ready, either the status is \"completed\" or \"error\".\n     * @param transcriptId - The ID of the transcript.\n     * @param options - The options to wait until the transcript is ready.\n     * @returns A promise that resolves to the transcript. The transcript status is \"completed\" or \"error\".\n     */\n    async waitUntilReady(transcriptId, options) {\n        const pollingInterval = options?.pollingInterval ?? 3_000;\n        const pollingTimeout = options?.pollingTimeout ?? -1;\n        const startTime = Date.now();\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const transcript = await this.get(transcriptId);\n            if (transcript.status === \"completed\" || transcript.status === \"error\") {\n                return transcript;\n            }\n            else if (pollingTimeout > 0 &&\n                Date.now() - startTime > pollingTimeout) {\n                throw new Error(\"Polling timeout\");\n            }\n            else {\n                await new Promise((resolve) => setTimeout(resolve, pollingInterval));\n            }\n        }\n    }\n    /**\n     * Retrieve a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the transcript.\n     */\n    get(id) {\n        return this.fetchJson(`/v2/transcript/${id}`);\n    }\n    /**\n     * Retrieves a page of transcript listings.\n     * @param params - The parameters to filter the transcript list by, or the URL to retrieve the transcript list from.\n     */\n    async list(params) {\n        let url = \"/v2/transcript\";\n        if (typeof params === \"string\") {\n            url = params;\n        }\n        else if (params) {\n            url = `${url}?${new URLSearchParams(Object.keys(params).map((key) => [\n                key,\n                params[key]?.toString() || \"\",\n            ]))}`;\n        }\n        const data = await this.fetchJson(url);\n        for (const transcriptListItem of data.transcripts) {\n            transcriptListItem.created = new Date(transcriptListItem.created);\n            if (transcriptListItem.completed) {\n                transcriptListItem.completed = new Date(transcriptListItem.completed);\n            }\n        }\n        return data;\n    }\n    /**\n     * Delete a transcript\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the transcript.\n     */\n    delete(id) {\n        return this.fetchJson(`/v2/transcript/${id}`, { method: \"DELETE\" });\n    }\n    /**\n     * Search through the transcript for a specific set of keywords.\n     * You can search for individual words, numbers, or phrases containing up to five words or numbers.\n     * @param id - The identifier of the transcript.\n     * @param words - Keywords to search for.\n     * @returns A promise that resolves to the sentences.\n     */\n    wordSearch(id, words) {\n        const params = new URLSearchParams({ words: words.join(\",\") });\n        return this.fetchJson(`/v2/transcript/${id}/word-search?${params.toString()}`);\n    }\n    /**\n     * Retrieve all sentences of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the sentences.\n     */\n    sentences(id) {\n        return this.fetchJson(`/v2/transcript/${id}/sentences`);\n    }\n    /**\n     * Retrieve all paragraphs of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the paragraphs.\n     */\n    paragraphs(id) {\n        return this.fetchJson(`/v2/transcript/${id}/paragraphs`);\n    }\n    /**\n     * Retrieve subtitles of a transcript.\n     * @param id - The identifier of the transcript.\n     * @param format - The format of the subtitles.\n     * @param chars_per_caption - The maximum number of characters per caption.\n     * @returns A promise that resolves to the subtitles text.\n     */\n    async subtitles(id, format = \"srt\", chars_per_caption) {\n        let url = `/v2/transcript/${id}/${format}`;\n        if (chars_per_caption) {\n            const params = new URLSearchParams();\n            params.set(\"chars_per_caption\", chars_per_caption.toString());\n            url += `?${params.toString()}`;\n        }\n        const response = await this.fetch(url);\n        return await response.text();\n    }\n    /**\n     * Retrieve the redacted audio URL of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the details of the redacted audio.\n     * @deprecated Use `redactedAudio` instead.\n     */\n    redactions(id) {\n        return this.redactedAudio(id);\n    }\n    /**\n     * Retrieve the redacted audio URL of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the details of the redacted audio.\n     */\n    redactedAudio(id) {\n        return this.fetchJson(`/v2/transcript/${id}/redacted-audio`);\n    }\n    /**\n     * Retrieve the redacted audio file of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the fetch HTTP response of the redacted audio file.\n     */\n    async redactedAudioFile(id) {\n        const { redacted_audio_url, status } = await this.redactedAudio(id);\n        if (status !== \"redacted_audio_ready\") {\n            throw new Error(`Redacted audio status is ${status}`);\n        }\n        const response = await fetch(redacted_audio_url);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch redacted audio: ${response.statusText}`);\n        }\n        return {\n            arrayBuffer: response.arrayBuffer.bind(response),\n            blob: response.blob.bind(response),\n            body: response.body,\n            bodyUsed: response.bodyUsed,\n        };\n    }\n}\n\nconst readFile = async (path) => stream__WEBPACK_IMPORTED_MODULE_3__.Readable.toWeb((0,fs__WEBPACK_IMPORTED_MODULE_2__.createReadStream)(path));\n\nclass FileService extends BaseService {\n    /**\n     * Upload a local file to AssemblyAI.\n     * @param input - The local file path to upload, or a stream or buffer of the file to upload.\n     * @returns A promise that resolves to the uploaded file URL.\n     */\n    async upload(input) {\n        let fileData;\n        if (typeof input === \"string\") {\n            if (input.startsWith(\"data:\")) {\n                fileData = dataUrlToBlob(input);\n            }\n            else {\n                fileData = await readFile(input);\n            }\n        }\n        else\n            fileData = input;\n        const data = await this.fetchJson(\"/v2/upload\", {\n            method: \"POST\",\n            body: fileData,\n            headers: {\n                \"Content-Type\": \"application/octet-stream\",\n            },\n            duplex: \"half\",\n        });\n        return data.upload_url;\n    }\n}\nfunction dataUrlToBlob(dataUrl) {\n    const arr = dataUrl.split(\",\");\n    const mime = arr[0].match(/:(.*?);/)[1];\n    const bstr = atob(arr[1]);\n    let n = bstr.length;\n    const u8arr = new Uint8Array(n);\n    while (n--) {\n        u8arr[n] = bstr.charCodeAt(n);\n    }\n    return new Blob([u8arr], { type: mime });\n}\n\nconst defaultBaseUrl = \"https://api.assemblyai.com\";\nclass AssemblyAI {\n    /**\n     * Create a new AssemblyAI client.\n     * @param params - The parameters for the service, including the API key and base URL, if any.\n     */\n    constructor(params) {\n        params.baseUrl = params.baseUrl || defaultBaseUrl;\n        if (params.baseUrl && params.baseUrl.endsWith(\"/\")) {\n            params.baseUrl = params.baseUrl.slice(0, -1);\n        }\n        this.files = new FileService(params);\n        this.transcripts = new TranscriptService(params, this.files);\n        this.lemur = new LemurService(params);\n        this.realtime = new RealtimeTranscriberFactory(params);\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXNzZW1ibHlhaS9kaXN0L25vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUE0QztBQUN4QjtBQUNrQjtBQUNKOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFLGdEQUFnRCxJQUFJLEdBQUcsVUFBVSxHQUFHLGFBQWE7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQixFQUFFLG9CQUFvQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEscUNBQXFDLDBDQUFFOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsMkJBQTJCO0FBQ2hFLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFjO0FBQ2pDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQyxXQUFXO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxHQUFHO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxHQUFHO0FBQzVCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsR0FBRyxLQUFLLGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFLGdEQUFnRCxHQUFHLGVBQWUsa0JBQWtCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEdBQUc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsR0FBRztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsR0FBRyxHQUFHLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxHQUFHO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyw0Q0FBUSxPQUFPLG9EQUFnQjs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdXNlbGVzcy1mdW4tYWkvLi9ub2RlX21vZHVsZXMvYXNzZW1ibHlhaS9kaXN0L25vZGUubWpzPzM4MDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV3JpdGFibGVTdHJlYW0gfSBmcm9tICdzdHJlYW0vd2ViJztcbmltcG9ydCB3cyBmcm9tICd3cyc7XG5pbXBvcnQgeyBjcmVhdGVSZWFkU3RyZWFtIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgUmVhZGFibGUgfSBmcm9tICdzdHJlYW0nO1xuXG5jb25zdCBERUZBVUxUX0ZFVENIX0lOSVQgPSB7XG4gICAgY2FjaGU6IFwibm8tc3RvcmVcIixcbn07XG5cbmNvbnN0IGJ1aWxkVXNlckFnZW50ID0gKHVzZXJBZ2VudCkgPT4gZGVmYXVsdFVzZXJBZ2VudFN0cmluZyArXG4gICAgKHVzZXJBZ2VudCA9PT0gZmFsc2VcbiAgICAgICAgPyBcIlwiXG4gICAgICAgIDogXCIgQXNzZW1ibHlBSS8xLjAgKFwiICtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHsgLi4uZGVmYXVsdFVzZXJBZ2VudCwgLi4udXNlckFnZW50IH0pXG4gICAgICAgICAgICAgICAgLm1hcCgoW2tleSwgaXRlbV0pID0+IGl0ZW0gPyBgJHtrZXl9PSR7aXRlbS5uYW1lfS8ke2l0ZW0udmVyc2lvbn1gIDogXCJcIilcbiAgICAgICAgICAgICAgICAuam9pbihcIiBcIikgK1xuICAgICAgICAgICAgXCIpXCIpO1xubGV0IGRlZmF1bHRVc2VyQWdlbnRTdHJpbmcgPSBcIlwiO1xuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCkge1xuICAgIGRlZmF1bHRVc2VyQWdlbnRTdHJpbmcgKz0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cbmNvbnN0IGRlZmF1bHRVc2VyQWdlbnQgPSB7XG4gICAgc2RrOiB7IG5hbWU6IFwiSmF2YVNjcmlwdFwiLCB2ZXJzaW9uOiBcIjQuNy4wXCIgfSxcbn07XG5pZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAocHJvY2Vzcy52ZXJzaW9ucy5ub2RlICYmIGRlZmF1bHRVc2VyQWdlbnRTdHJpbmcuaW5kZXhPZihcIk5vZGVcIikgPT09IC0xKSB7XG4gICAgICAgIGRlZmF1bHRVc2VyQWdlbnQucnVudGltZV9lbnYgPSB7XG4gICAgICAgICAgICBuYW1lOiBcIk5vZGVcIixcbiAgICAgICAgICAgIHZlcnNpb246IHByb2Nlc3MudmVyc2lvbnMubm9kZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MudmVyc2lvbnMuYnVuICYmIGRlZmF1bHRVc2VyQWdlbnRTdHJpbmcuaW5kZXhPZihcIkJ1blwiKSA9PT0gLTEpIHtcbiAgICAgICAgZGVmYXVsdFVzZXJBZ2VudC5ydW50aW1lX2VudiA9IHtcbiAgICAgICAgICAgIG5hbWU6IFwiQnVuXCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiBwcm9jZXNzLnZlcnNpb25zLmJ1bixcbiAgICAgICAgfTtcbiAgICB9XG59XG5pZiAodHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAocHJvY2Vzcy52ZXJzaW9ucy5idW4gJiYgZGVmYXVsdFVzZXJBZ2VudFN0cmluZy5pbmRleE9mKFwiRGVub1wiKSA9PT0gLTEpIHtcbiAgICAgICAgZGVmYXVsdFVzZXJBZ2VudC5ydW50aW1lX2VudiA9IHsgbmFtZTogXCJEZW5vXCIsIHZlcnNpb246IERlbm8udmVyc2lvbi5kZW5vIH07XG4gICAgfVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHNlcnZpY2VzIHRoYXQgY29tbXVuaWNhdGUgd2l0aCB0aGUgQVBJLlxuICovXG5jbGFzcyBCYXNlU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlcnZpY2UuXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIHVzZSBmb3IgdGhlIHNlcnZpY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBpZiAocGFyYW1zLnVzZXJBZ2VudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckFnZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51c2VyQWdlbnQgPSBidWlsZFVzZXJBZ2VudChwYXJhbXMudXNlckFnZW50IHx8IHt9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmZXRjaChpbnB1dCwgaW5pdCkge1xuICAgICAgICBpbml0ID0geyAuLi5ERUZBVUxUX0ZFVENIX0lOSVQsIC4uLmluaXQgfTtcbiAgICAgICAgbGV0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiB0aGlzLnBhcmFtcy5hcGlLZXksXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKERFRkFVTFRfRkVUQ0hfSU5JVD8uaGVhZGVycylcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7IC4uLmhlYWRlcnMsIC4uLkRFRkFVTFRfRkVUQ0hfSU5JVC5oZWFkZXJzIH07XG4gICAgICAgIGlmIChpbml0Py5oZWFkZXJzKVxuICAgICAgICAgICAgaGVhZGVycyA9IHsgLi4uaGVhZGVycywgLi4uaW5pdC5oZWFkZXJzIH07XG4gICAgICAgIGlmICh0aGlzLnVzZXJBZ2VudCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlVzZXItQWdlbnRcIl0gPSB0aGlzLnVzZXJBZ2VudDtcbiAgICAgICAgICAgIC8vIGNocm9taXVtIGJyb3dzZXJzIGhhdmUgYSBidWcgd2hlcmUgdGhlIHVzZXIgYWdlbnQgY2FuJ3QgYmUgbW9kaWZpZWRcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIFwiY2hyb21lXCIgaW4gd2luZG93KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1tcIkFzc2VtYmx5QUktQWdlbnRcIl0gPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJBZ2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbml0LmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICBpZiAoIWlucHV0LnN0YXJ0c1dpdGgoXCJodHRwXCIpKVxuICAgICAgICAgICAgaW5wdXQgPSB0aGlzLnBhcmFtcy5iYXNlVXJsICsgaW5wdXQ7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goaW5wdXQsIGluaXQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgbGV0IGpzb247XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAvKiBlbXB0eSAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoanNvbj8uZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihqc29uLmVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaEpzb24oaW5wdXQsIGluaXQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKGlucHV0LCBpbml0KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG59XG5cbmNsYXNzIExlbXVyU2VydmljZSBleHRlbmRzIEJhc2VTZXJ2aWNlIHtcbiAgICBzdW1tYXJ5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oXCIvbGVtdXIvdjMvZ2VuZXJhdGUvc3VtbWFyeVwiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHF1ZXN0aW9uQW5zd2VyKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oXCIvbGVtdXIvdjMvZ2VuZXJhdGUvcXVlc3Rpb24tYW5zd2VyXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWN0aW9uSXRlbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoSnNvbihcIi9sZW11ci92My9nZW5lcmF0ZS9hY3Rpb24taXRlbXNcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0YXNrKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oXCIvbGVtdXIvdjMvZ2VuZXJhdGUvdGFza1wiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFJlc3BvbnNlKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoSnNvbihgL2xlbXVyL3YzLyR7aWR9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgZGF0YSBmb3IgYSBwcmV2aW91c2x5IHN1Ym1pdHRlZCBMZU1VUiByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBpZCAtIElEIG9mIHRoZSBMZU1VUiByZXF1ZXN0XG4gICAgICovXG4gICAgcHVyZ2VSZXF1ZXN0RGF0YShpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oYC9sZW11ci92My8ke2lkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBmYWN0b3J5ID0gKHVybCwgcGFyYW1zKSA9PiBuZXcgd3ModXJsLCBwYXJhbXMpO1xuXG5jb25zdCBSZWFsdGltZUVycm9yVHlwZSA9IHtcbiAgICBCYWRTYW1wbGVSYXRlOiA0MDAwLFxuICAgIEF1dGhGYWlsZWQ6IDQwMDEsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIEluc3VmZmljaWVudEZ1bmRzIG9yIEZyZWVUaWVyVXNlciBpbnN0ZWFkXG4gICAgICovXG4gICAgSW5zdWZmaWNpZW50RnVuZHNPckZyZWVBY2NvdW50OiA0MDAyLFxuICAgIEluc3VmZmljaWVudEZ1bmRzOiA0MDAyLFxuICAgIEZyZWVUaWVyVXNlcjogNDAwMyxcbiAgICBOb25leGlzdGVudFNlc3Npb25JZDogNDAwNCxcbiAgICBTZXNzaW9uRXhwaXJlZDogNDAwOCxcbiAgICBDbG9zZWRTZXNzaW9uOiA0MDEwLFxuICAgIFJhdGVMaW1pdGVkOiA0MDI5LFxuICAgIFVuaXF1ZVNlc3Npb25WaW9sYXRpb246IDQwMzAsXG4gICAgU2Vzc2lvblRpbWVvdXQ6IDQwMzEsXG4gICAgQXVkaW9Ub29TaG9ydDogNDAzMixcbiAgICBBdWRpb1Rvb0xvbmc6IDQwMzMsXG4gICAgQXVkaW9Ub29TbWFsbFRvVHJhbnNjb2RlOiA0MDM0LFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIERvbid0IHVzZVxuICAgICAqL1xuICAgIEJhZEpzb246IDQxMDAsXG4gICAgQmFkU2NoZW1hOiA0MTAxLFxuICAgIFRvb01hbnlTdHJlYW1zOiA0MTAyLFxuICAgIFJlY29ubmVjdGVkOiA0MTAzLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIERvbid0IHVzZVxuICAgICAqL1xuICAgIFJlY29ubmVjdEF0dGVtcHRzRXhoYXVzdGVkOiAxMDEzLFxuICAgIFdvcmRCb29zdFBhcmFtZXRlclBhcnNpbmdGYWlsZWQ6IDQxMDQsXG59O1xuY29uc3QgUmVhbHRpbWVFcnJvck1lc3NhZ2VzID0ge1xuICAgIFtSZWFsdGltZUVycm9yVHlwZS5CYWRTYW1wbGVSYXRlXTogXCJTYW1wbGUgcmF0ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiLFxuICAgIFtSZWFsdGltZUVycm9yVHlwZS5BdXRoRmFpbGVkXTogXCJOb3QgQXV0aG9yaXplZFwiLFxuICAgIFtSZWFsdGltZUVycm9yVHlwZS5JbnN1ZmZpY2llbnRGdW5kc106IFwiSW5zdWZmaWNpZW50IGZ1bmRzXCIsXG4gICAgW1JlYWx0aW1lRXJyb3JUeXBlLkZyZWVUaWVyVXNlcl06IFwiVGhpcyBmZWF0dXJlIGlzIHBhaWQtb25seSBhbmQgcmVxdWlyZXMgeW91IHRvIGFkZCBhIGNyZWRpdCBjYXJkLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9hcHAuYXNzZW1ibHlhaS5jb20vIHRvIGFkZCBhIGNyZWRpdCBjYXJkIHRvIHlvdXIgYWNjb3VudC5cIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuTm9uZXhpc3RlbnRTZXNzaW9uSWRdOiBcIlNlc3Npb24gSUQgZG9lcyBub3QgZXhpc3RcIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuU2Vzc2lvbkV4cGlyZWRdOiBcIlNlc3Npb24gaGFzIGV4cGlyZWRcIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuQ2xvc2VkU2Vzc2lvbl06IFwiU2Vzc2lvbiBpcyBjbG9zZWRcIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuUmF0ZUxpbWl0ZWRdOiBcIlJhdGUgbGltaXRlZFwiLFxuICAgIFtSZWFsdGltZUVycm9yVHlwZS5VbmlxdWVTZXNzaW9uVmlvbGF0aW9uXTogXCJVbmlxdWUgc2Vzc2lvbiB2aW9sYXRpb25cIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuU2Vzc2lvblRpbWVvdXRdOiBcIlNlc3Npb24gVGltZW91dFwiLFxuICAgIFtSZWFsdGltZUVycm9yVHlwZS5BdWRpb1Rvb1Nob3J0XTogXCJBdWRpbyB0b28gc2hvcnRcIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuQXVkaW9Ub29Mb25nXTogXCJBdWRpbyB0b28gbG9uZ1wiLFxuICAgIFtSZWFsdGltZUVycm9yVHlwZS5BdWRpb1Rvb1NtYWxsVG9UcmFuc2NvZGVdOiBcIkF1ZGlvIHRvbyBzbWFsbCB0byB0cmFuc2NvZGVcIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuQmFkSnNvbl06IFwiQmFkIEpTT05cIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuQmFkU2NoZW1hXTogXCJCYWQgc2NoZW1hXCIsXG4gICAgW1JlYWx0aW1lRXJyb3JUeXBlLlRvb01hbnlTdHJlYW1zXTogXCJUb28gbWFueSBzdHJlYW1zXCIsXG4gICAgW1JlYWx0aW1lRXJyb3JUeXBlLlJlY29ubmVjdGVkXTogXCJUaGlzIHNlc3Npb24gaGFzIGJlZW4gcmVjb25uZWN0ZWQuIFRoaXMgV2ViU29ja2V0IGlzIG5vIGxvbmdlciB2YWxpZC5cIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuUmVjb25uZWN0QXR0ZW1wdHNFeGhhdXN0ZWRdOiBcIlJlY29ubmVjdCBhdHRlbXB0cyBleGhhdXN0ZWRcIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuV29yZEJvb3N0UGFyYW1ldGVyUGFyc2luZ0ZhaWxlZF06IFwiQ291bGQgbm90IHBhcnNlIHdvcmQgYm9vc3QgcGFyYW1ldGVyXCIsXG59O1xuY2xhc3MgUmVhbHRpbWVFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cblxuY29uc3QgZGVmYXVsdFJlYWx0aW1lVXJsID0gXCJ3c3M6Ly9hcGkuYXNzZW1ibHlhaS5jb20vdjIvcmVhbHRpbWUvd3NcIjtcbmNvbnN0IGZvcmNlRW5kT2ZVdHRlcmFuY2VNZXNzYWdlID0gYHtcImZvcmNlX2VuZF91dHRlcmFuY2VcIjp0cnVlfWA7XG5jb25zdCB0ZXJtaW5hdGVTZXNzaW9uTWVzc2FnZSA9IGB7XCJ0ZXJtaW5hdGVfc2Vzc2lvblwiOnRydWV9YDtcbi8qKlxuICogUmVhbHRpbWVUcmFuc2NyaWJlciBjb25uZWN0cyB0byB0aGUgU3RyZWFtaW5nIFNwZWVjaC10by1UZXh0IEFQSSBhbmQgbGV0cyB5b3UgdHJhbnNjcmliZSBhdWRpbyBpbiByZWFsLXRpbWUuXG4gKi9cbmNsYXNzIFJlYWx0aW1lVHJhbnNjcmliZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBSZWFsdGltZVRyYW5zY3JpYmVyLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIHRvIGNvbmZpZ3VyZSB0aGUgUmVhbHRpbWVUcmFuc2NyaWJlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgICAgICB0aGlzLnJlYWx0aW1lVXJsID0gcGFyYW1zLnJlYWx0aW1lVXJsID8/IGRlZmF1bHRSZWFsdGltZVVybDtcbiAgICAgICAgdGhpcy5zYW1wbGVSYXRlID0gcGFyYW1zLnNhbXBsZVJhdGUgPz8gMTZfMDAwO1xuICAgICAgICB0aGlzLndvcmRCb29zdCA9IHBhcmFtcy53b3JkQm9vc3Q7XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSBwYXJhbXMuZW5jb2Rpbmc7XG4gICAgICAgIHRoaXMuZW5kVXR0ZXJhbmNlU2lsZW5jZVRocmVzaG9sZCA9IHBhcmFtcy5lbmRVdHRlcmFuY2VTaWxlbmNlVGhyZXNob2xkO1xuICAgICAgICB0aGlzLmRpc2FibGVQYXJ0aWFsVHJhbnNjcmlwdHMgPSBwYXJhbXMuZGlzYWJsZVBhcnRpYWxUcmFuc2NyaXB0cztcbiAgICAgICAgaWYgKFwidG9rZW5cIiBpbiBwYXJhbXMgJiYgcGFyYW1zLnRva2VuKVxuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHBhcmFtcy50b2tlbjtcbiAgICAgICAgaWYgKFwiYXBpS2V5XCIgaW4gcGFyYW1zICYmIHBhcmFtcy5hcGlLZXkpXG4gICAgICAgICAgICB0aGlzLmFwaUtleSA9IHBhcmFtcy5hcGlLZXk7XG4gICAgICAgIGlmICghKHRoaXMudG9rZW4gfHwgdGhpcy5hcGlLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBUEkga2V5IG9yIHRlbXBvcmFyeSB0b2tlbiBpcyByZXF1aXJlZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdGlvblVybCgpIHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnJlYWx0aW1lVXJsKTtcbiAgICAgICAgaWYgKHVybC5wcm90b2NvbCAhPT0gXCJ3c3M6XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvdG9jb2wsIG11c3QgYmUgd3NzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW4pIHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tlblwiLCB0aGlzLnRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBzZWFyY2hQYXJhbXMuc2V0KFwic2FtcGxlX3JhdGVcIiwgdGhpcy5zYW1wbGVSYXRlLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAodGhpcy53b3JkQm9vc3QgJiYgdGhpcy53b3JkQm9vc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLnNldChcIndvcmRfYm9vc3RcIiwgSlNPTi5zdHJpbmdpZnkodGhpcy53b3JkQm9vc3QpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbmNvZGluZykge1xuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLnNldChcImVuY29kaW5nXCIsIHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJlbmFibGVfZXh0cmFfc2Vzc2lvbl9pbmZvcm1hdGlvblwiLCBcInRydWVcIik7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVQYXJ0aWFsVHJhbnNjcmlwdHMpIHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJkaXNhYmxlX3BhcnRpYWxfdHJhbnNjcmlwdHNcIiwgdGhpcy5kaXNhYmxlUGFydGlhbFRyYW5zY3JpcHRzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHVybC5zZWFyY2ggPSBzZWFyY2hQYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZm9yIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBldmVudCB0byBsaXN0ZW4gZm9yLlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRdID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gdGhlIHNlcnZlciBhbmQgYmVnaW4gYSBuZXcgc2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIGFuZCB0aGUgc2Vzc2lvbiBiZWdpbnMuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IGNvbm5lY3RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHRoaXMuY29ubmVjdGlvblVybCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldCA9IGZhY3RvcnkodXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSBmYWN0b3J5KHVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgQXV0aG9yaXphdGlvbjogdGhpcy5hcGlLZXkgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kVXR0ZXJhbmNlU2lsZW5jZVRocmVzaG9sZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kVXR0ZXJhbmNlU2lsZW5jZVRocmVzaG9sZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJlRW5kVXR0ZXJhbmNlU2lsZW5jZVRocmVzaG9sZCh0aGlzLmVuZFV0dGVyYW5jZVNpbGVuY2VUaHJlc2hvbGQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSAoeyBjb2RlLCByZWFzb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlIGluIFJlYWx0aW1lRXJyb3JNZXNzYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gUmVhbHRpbWVFcnJvck1lc3NhZ2VzW2NvZGVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmNsb3NlPy4oY29kZSwgcmVhc29uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5lcnJvcj8uKGV2ZW50LmVycm9yKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmVycm9yPy4obmV3IEVycm9yKGV2ZW50Lm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbm1lc3NhZ2UgPSAoeyBkYXRhIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShkYXRhLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5lcnJvcj8uKG5ldyBSZWFsdGltZUVycm9yKG1lc3NhZ2UuZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UubWVzc2FnZV90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTZXNzaW9uQmVnaW5zXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZW5PYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkOiBtZXNzYWdlLnNlc3Npb25faWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShtZXNzYWdlLmV4cGlyZXNfYXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3Blbk9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5vcGVuPy4ob3Blbk9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUGFydGlhbFRyYW5zY3JpcHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVzc2FnZS5jcmVhdGVkIGlzIGFjdHVhbGx5IGEgc3RyaW5nIHdoZW4gY29taW5nIGZyb20gdGhlIHNvY2tldFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGVkID0gbmV3IERhdGUobWVzc2FnZS5jcmVhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnRyYW5zY3JpcHQ/LihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW1widHJhbnNjcmlwdC5wYXJ0aWFsXCJdPy4obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRmluYWxUcmFuc2NyaXB0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UuY3JlYXRlZCBpcyBhY3R1YWxseSBhIHN0cmluZyB3aGVuIGNvbWluZyBmcm9tIHRoZSBzb2NrZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3JlYXRlZCA9IG5ldyBEYXRlKG1lc3NhZ2UuY3JlYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy50cmFuc2NyaXB0Py4obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1tcInRyYW5zY3JpcHQuZmluYWxcIl0/LihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTZXNzaW9uSW5mb3JtYXRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuc2Vzc2lvbl9pbmZvcm1hdGlvbj8uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNlc3Npb25UZXJtaW5hdGVkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvblRlcm1pbmF0ZWRSZXNvbHZlPy4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYXVkaW8gZGF0YSB0byB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSBhdWRpbyAtIFRoZSBhdWRpbyBkYXRhIHRvIHNlbmQgdG8gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBzZW5kQXVkaW8oYXVkaW8pIHtcbiAgICAgICAgdGhpcy5zZW5kKGF1ZGlvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd3JpdGFibGUgc3RyZWFtIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2VuZCBhdWRpbyBkYXRhIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHJldHVybnMgQSB3cml0YWJsZSBzdHJlYW0gdGhhdCBjYW4gYmUgdXNlZCB0byBzZW5kIGF1ZGlvIGRhdGEgdG8gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBzdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGU6IChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEF1ZGlvKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYW51YWxseSBlbmQgYW4gdXR0ZXJhbmNlXG4gICAgICovXG4gICAgZm9yY2VFbmRVdHRlcmFuY2UoKSB7XG4gICAgICAgIHRoaXMuc2VuZChmb3JjZUVuZE9mVXR0ZXJhbmNlTWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZSB0aGUgdGhyZXNob2xkIGZvciBob3cgbG9uZyB0byB3YWl0IGJlZm9yZSBlbmRpbmcgYW4gdXR0ZXJhbmNlLiBEZWZhdWx0IGlzIDcwMG1zLlxuICAgICAqIEBwYXJhbSB0aHJlc2hvbGQgLSBUaGUgZHVyYXRpb24gb2YgdGhlIGVuZCB1dHRlcmFuY2Ugc2lsZW5jZSB0aHJlc2hvbGQgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIFRoaXMgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMjBfMDAwLlxuICAgICAqL1xuICAgIGNvbmZpZ3VyZUVuZFV0dGVyYW5jZVNpbGVuY2VUaHJlc2hvbGQodGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMuc2VuZChge1wiZW5kX3V0dGVyYW5jZV9zaWxlbmNlX3RocmVzaG9sZFwiOiR7dGhyZXNob2xkfX1gKTtcbiAgICB9XG4gICAgc2VuZChkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5zb2NrZXQgfHwgdGhpcy5zb2NrZXQucmVhZHlTdGF0ZSAhPT0gdGhpcy5zb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29ja2V0IGlzIG5vdCBvcGVuIGZvciBjb21tdW5pY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHdhaXRGb3JTZXNzaW9uVGVybWluYXRpb24gLSBJZiB0cnVlLCB0aGUgbWV0aG9kIHdpbGwgd2FpdCBmb3IgdGhlIHNlc3Npb24gdG8gYmUgdGVybWluYXRlZCBiZWZvcmUgY2xvc2luZyB0aGUgY29ubmVjdGlvbi5cbiAgICAgKiBXaGlsZSB3YWl0aW5nIGZvciB0aGUgc2Vzc2lvbiB0byBiZSB0ZXJtaW5hdGVkLCB5b3Ugd2lsbCByZWNlaXZlIHRoZSBmaW5hbCB0cmFuc2NyaXB0IGFuZCBzZXNzaW9uIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlKHdhaXRGb3JTZXNzaW9uVGVybWluYXRpb24gPSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0LnJlYWR5U3RhdGUgPT09IHRoaXMuc29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICAgICAgICBpZiAod2FpdEZvclNlc3Npb25UZXJtaW5hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uVGVybWluYXRlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uVGVybWluYXRlZFJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZCh0ZXJtaW5hdGVTZXNzaW9uTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlc3Npb25UZXJtaW5hdGVkUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQodGVybWluYXRlU2Vzc2lvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNvY2tldD8ucmVtb3ZlQWxsTGlzdGVuZXJzKVxuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgICAgICB0aGlzLnNvY2tldCA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBSZWFsdGltZVRyYW5zY3JpYmVyIGluc3RlYWRcbiAqL1xuY2xhc3MgUmVhbHRpbWVTZXJ2aWNlIGV4dGVuZHMgUmVhbHRpbWVUcmFuc2NyaWJlciB7XG59XG5cbmNsYXNzIFJlYWx0aW1lVHJhbnNjcmliZXJGYWN0b3J5IGV4dGVuZHMgQmFzZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgICB0aGlzLnJ0RmFjdG9yeVBhcmFtcyA9IHBhcmFtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHRyYW5zY3JpYmVyKC4uLikgaW5zdGVhZFxuICAgICAqL1xuICAgIGNyZWF0ZVNlcnZpY2UocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zY3JpYmVyKHBhcmFtcyk7XG4gICAgfVxuICAgIHRyYW5zY3JpYmVyKHBhcmFtcykge1xuICAgICAgICBjb25zdCBzZXJ2aWNlUGFyYW1zID0geyAuLi5wYXJhbXMgfTtcbiAgICAgICAgaWYgKCFzZXJ2aWNlUGFyYW1zLnRva2VuICYmICFzZXJ2aWNlUGFyYW1zLmFwaUtleSkge1xuICAgICAgICAgICAgc2VydmljZVBhcmFtcy5hcGlLZXkgPSB0aGlzLnJ0RmFjdG9yeVBhcmFtcy5hcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZWFsdGltZVRyYW5zY3JpYmVyKHNlcnZpY2VQYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVUZW1wb3JhcnlUb2tlbihwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hKc29uKFwiL3YyL3JlYWx0aW1lL3Rva2VuXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGEudG9rZW47XG4gICAgfVxufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgUmVhbHRpbWVUcmFuc2NyaWJlckZhY3RvcnkgaW5zdGVhZFxuICovXG5jbGFzcyBSZWFsdGltZVNlcnZpY2VGYWN0b3J5IGV4dGVuZHMgUmVhbHRpbWVUcmFuc2NyaWJlckZhY3Rvcnkge1xufVxuXG5mdW5jdGlvbiBnZXRQYXRoKHBhdGgpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiaHR0cFwiKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aChcImh0dHBzXCIpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiZGF0YTpcIikpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKVxuICAgICAgICByZXR1cm4gcGF0aC5zdWJzdHJpbmcoNyk7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aChcImZpbGU6XCIpKVxuICAgICAgICByZXR1cm4gcGF0aC5zdWJzdHJpbmcoNSk7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbmNsYXNzIFRyYW5zY3JpcHRTZXJ2aWNlIGV4dGVuZHMgQmFzZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcywgZmlsZXMpIHtcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgICAgdGhpcy5maWxlcyA9IGZpbGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2NyaWJlIGFuIGF1ZGlvIGZpbGUuIFRoaXMgd2lsbCBjcmVhdGUgYSB0cmFuc2NyaXB0IGFuZCB3YWl0IHVudGlsIHRoZSB0cmFuc2NyaXB0IHN0YXR1cyBpcyBcImNvbXBsZXRlZFwiIG9yIFwiZXJyb3JcIi5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gdHJhbnNjcmliZSBhbiBhdWRpbyBmaWxlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdHJhbnNjcmliZSBhbiBhdWRpbyBmaWxlLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmFuc2NyaXB0LiBUaGUgdHJhbnNjcmlwdCBzdGF0dXMgaXMgXCJjb21wbGV0ZWRcIiBvciBcImVycm9yXCIuXG4gICAgICovXG4gICAgYXN5bmMgdHJhbnNjcmliZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IGF3YWl0IHRoaXMuc3VibWl0KHBhcmFtcyk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndhaXRVbnRpbFJlYWR5KHRyYW5zY3JpcHQuaWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJtaXRzIGEgdHJhbnNjcmlwdGlvbiBqb2IgZm9yIGFuIGF1ZGlvIGZpbGUuIFRoaXMgd2lsbCBub3Qgd2FpdCB1bnRpbCB0aGUgdHJhbnNjcmlwdCBzdGF0dXMgaXMgXCJjb21wbGV0ZWRcIiBvciBcImVycm9yXCIuXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIHN0YXJ0IHRoZSB0cmFuc2NyaXB0aW9uIG9mIGFuIGF1ZGlvIGZpbGUuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHF1ZXVlZCB0cmFuc2NyaXB0LlxuICAgICAqL1xuICAgIGFzeW5jIHN1Ym1pdChwYXJhbXMpIHtcbiAgICAgICAgbGV0IGF1ZGlvVXJsO1xuICAgICAgICBsZXQgdHJhbnNjcmlwdFBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFwiYXVkaW9cIiBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXVkaW8sIC4uLmF1ZGlvVHJhbnNjcmlwdFBhcmFtcyB9ID0gcGFyYW1zO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdWRpbyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBnZXRQYXRoKGF1ZGlvKTtcbiAgICAgICAgICAgICAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhdWRpbyBpcyBsb2NhbCBwYXRoLCB1cGxvYWQgbG9jYWwgZmlsZVxuICAgICAgICAgICAgICAgICAgICBhdWRpb1VybCA9IGF3YWl0IHRoaXMuZmlsZXMudXBsb2FkKHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9VcmwgPSBhd2FpdCB0aGlzLmZpbGVzLnVwbG9hZChhdWRpbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdWRpbyBpcyBub3QgYSBsb2NhbCBwYXRoLCBhbmQgbm90IGEgZGF0YS1VUkksIGFzc3VtZSBpdCdzIGEgbm9ybWFsIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9VcmwgPSBhdWRpbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGF1ZGlvIGlzIG9mIHVwbG9hZGFibGUgdHlwZVxuICAgICAgICAgICAgICAgIGF1ZGlvVXJsID0gYXdhaXQgdGhpcy5maWxlcy51cGxvYWQoYXVkaW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNjcmlwdFBhcmFtcyA9IHsgLi4uYXVkaW9UcmFuc2NyaXB0UGFyYW1zLCBhdWRpb191cmw6IGF1ZGlvVXJsIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2NyaXB0UGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmZldGNoSnNvbihcIi92Mi90cmFuc2NyaXB0XCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0cmFuc2NyaXB0UGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0cmFuc2NyaXB0LlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSB0cmFuc2NyaXB0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdXNlZCBmb3IgY3JlYXRpbmcgdGhlIG5ldyB0cmFuc2NyaXB0LlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmFuc2NyaXB0LlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgdHJhbnNjcmliZWAgaW5zdGVhZCB0byB0cmFuc2NyaWJlIGEgYXVkaW8gZmlsZSB0aGF0IGluY2x1ZGVzIHBvbGxpbmcsIG9yIGBzdWJtaXRgIHRvIHRyYW5zY3JpYmUgYSBhdWRpbyBmaWxlIHdpdGhvdXQgcG9sbGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBnZXRQYXRoKHBhcmFtcy5hdWRpb191cmwpO1xuICAgICAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdXBsb2FkVXJsID0gYXdhaXQgdGhpcy5maWxlcy51cGxvYWQocGF0aCk7XG4gICAgICAgICAgICBwYXJhbXMuYXVkaW9fdXJsID0gdXBsb2FkVXJsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmZldGNoSnNvbihcIi92Mi90cmFuc2NyaXB0XCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGwgPz8gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMud2FpdFVudGlsUmVhZHkoZGF0YS5pZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXQgdW50aWwgdGhlIHRyYW5zY3JpcHQgcmVhZHksIGVpdGhlciB0aGUgc3RhdHVzIGlzIFwiY29tcGxldGVkXCIgb3IgXCJlcnJvclwiLlxuICAgICAqIEBwYXJhbSB0cmFuc2NyaXB0SWQgLSBUaGUgSUQgb2YgdGhlIHRyYW5zY3JpcHQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB3YWl0IHVudGlsIHRoZSB0cmFuc2NyaXB0IGlzIHJlYWR5LlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmFuc2NyaXB0LiBUaGUgdHJhbnNjcmlwdCBzdGF0dXMgaXMgXCJjb21wbGV0ZWRcIiBvciBcImVycm9yXCIuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdFVudGlsUmVhZHkodHJhbnNjcmlwdElkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBvbGxpbmdJbnRlcnZhbCA9IG9wdGlvbnM/LnBvbGxpbmdJbnRlcnZhbCA/PyAzXzAwMDtcbiAgICAgICAgY29uc3QgcG9sbGluZ1RpbWVvdXQgPSBvcHRpb25zPy5wb2xsaW5nVGltZW91dCA/PyAtMTtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IGF3YWl0IHRoaXMuZ2V0KHRyYW5zY3JpcHRJZCk7XG4gICAgICAgICAgICBpZiAodHJhbnNjcmlwdC5zdGF0dXMgPT09IFwiY29tcGxldGVkXCIgfHwgdHJhbnNjcmlwdC5zdGF0dXMgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2NyaXB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocG9sbGluZ1RpbWVvdXQgPiAwICYmXG4gICAgICAgICAgICAgICAgRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+IHBvbGxpbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9sbGluZyB0aW1lb3V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcG9sbGluZ0ludGVydmFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSB0cmFuc2NyaXB0LlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZGVudGlmaWVyIG9mIHRoZSB0cmFuc2NyaXB0LlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmFuc2NyaXB0LlxuICAgICAqL1xuICAgIGdldChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oYC92Mi90cmFuc2NyaXB0LyR7aWR9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHBhZ2Ugb2YgdHJhbnNjcmlwdCBsaXN0aW5ncy5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gZmlsdGVyIHRoZSB0cmFuc2NyaXB0IGxpc3QgYnksIG9yIHRoZSBVUkwgdG8gcmV0cmlldmUgdGhlIHRyYW5zY3JpcHQgbGlzdCBmcm9tLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3QocGFyYW1zKSB7XG4gICAgICAgIGxldCB1cmwgPSBcIi92Mi90cmFuc2NyaXB0XCI7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB1cmwgPSBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICB1cmwgPSBgJHt1cmx9PyR7bmV3IFVSTFNlYXJjaFBhcmFtcyhPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoa2V5KSA9PiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHBhcmFtc1trZXldPy50b1N0cmluZygpIHx8IFwiXCIsXG4gICAgICAgICAgICBdKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5mZXRjaEpzb24odXJsKTtcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2NyaXB0TGlzdEl0ZW0gb2YgZGF0YS50cmFuc2NyaXB0cykge1xuICAgICAgICAgICAgdHJhbnNjcmlwdExpc3RJdGVtLmNyZWF0ZWQgPSBuZXcgRGF0ZSh0cmFuc2NyaXB0TGlzdEl0ZW0uY3JlYXRlZCk7XG4gICAgICAgICAgICBpZiAodHJhbnNjcmlwdExpc3RJdGVtLmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIHRyYW5zY3JpcHRMaXN0SXRlbS5jb21wbGV0ZWQgPSBuZXcgRGF0ZSh0cmFuc2NyaXB0TGlzdEl0ZW0uY29tcGxldGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgdHJhbnNjcmlwdFxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZGVudGlmaWVyIG9mIHRoZSB0cmFuc2NyaXB0LlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmFuc2NyaXB0LlxuICAgICAqL1xuICAgIGRlbGV0ZShpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oYC92Mi90cmFuc2NyaXB0LyR7aWR9YCwgeyBtZXRob2Q6IFwiREVMRVRFXCIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCB0aHJvdWdoIHRoZSB0cmFuc2NyaXB0IGZvciBhIHNwZWNpZmljIHNldCBvZiBrZXl3b3Jkcy5cbiAgICAgKiBZb3UgY2FuIHNlYXJjaCBmb3IgaW5kaXZpZHVhbCB3b3JkcywgbnVtYmVycywgb3IgcGhyYXNlcyBjb250YWluaW5nIHVwIHRvIGZpdmUgd29yZHMgb3IgbnVtYmVycy5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWRlbnRpZmllciBvZiB0aGUgdHJhbnNjcmlwdC5cbiAgICAgKiBAcGFyYW0gd29yZHMgLSBLZXl3b3JkcyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzZW50ZW5jZXMuXG4gICAgICovXG4gICAgd29yZFNlYXJjaChpZCwgd29yZHMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IHdvcmRzOiB3b3Jkcy5qb2luKFwiLFwiKSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hKc29uKGAvdjIvdHJhbnNjcmlwdC8ke2lkfS93b3JkLXNlYXJjaD8ke3BhcmFtcy50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgc2VudGVuY2VzIG9mIGEgdHJhbnNjcmlwdC5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWRlbnRpZmllciBvZiB0aGUgdHJhbnNjcmlwdC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc2VudGVuY2VzLlxuICAgICAqL1xuICAgIHNlbnRlbmNlcyhpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oYC92Mi90cmFuc2NyaXB0LyR7aWR9L3NlbnRlbmNlc2ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgcGFyYWdyYXBocyBvZiBhIHRyYW5zY3JpcHQuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkZW50aWZpZXIgb2YgdGhlIHRyYW5zY3JpcHQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBhcmFncmFwaHMuXG4gICAgICovXG4gICAgcGFyYWdyYXBocyhpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oYC92Mi90cmFuc2NyaXB0LyR7aWR9L3BhcmFncmFwaHNgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgc3VidGl0bGVzIG9mIGEgdHJhbnNjcmlwdC5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWRlbnRpZmllciBvZiB0aGUgdHJhbnNjcmlwdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBvZiB0aGUgc3VidGl0bGVzLlxuICAgICAqIEBwYXJhbSBjaGFyc19wZXJfY2FwdGlvbiAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHBlciBjYXB0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzdWJ0aXRsZXMgdGV4dC5cbiAgICAgKi9cbiAgICBhc3luYyBzdWJ0aXRsZXMoaWQsIGZvcm1hdCA9IFwic3J0XCIsIGNoYXJzX3Blcl9jYXB0aW9uKSB7XG4gICAgICAgIGxldCB1cmwgPSBgL3YyL3RyYW5zY3JpcHQvJHtpZH0vJHtmb3JtYXR9YDtcbiAgICAgICAgaWYgKGNoYXJzX3Blcl9jYXB0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KFwiY2hhcnNfcGVyX2NhcHRpb25cIiwgY2hhcnNfcGVyX2NhcHRpb24udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB1cmwgKz0gYD8ke3BhcmFtcy50b1N0cmluZygpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHVybCk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSByZWRhY3RlZCBhdWRpbyBVUkwgb2YgYSB0cmFuc2NyaXB0LlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZGVudGlmaWVyIG9mIHRoZSB0cmFuc2NyaXB0LlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXRhaWxzIG9mIHRoZSByZWRhY3RlZCBhdWRpby5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYHJlZGFjdGVkQXVkaW9gIGluc3RlYWQuXG4gICAgICovXG4gICAgcmVkYWN0aW9ucyhpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWRhY3RlZEF1ZGlvKGlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHJlZGFjdGVkIGF1ZGlvIFVSTCBvZiBhIHRyYW5zY3JpcHQuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkZW50aWZpZXIgb2YgdGhlIHRyYW5zY3JpcHQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRldGFpbHMgb2YgdGhlIHJlZGFjdGVkIGF1ZGlvLlxuICAgICAqL1xuICAgIHJlZGFjdGVkQXVkaW8oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hKc29uKGAvdjIvdHJhbnNjcmlwdC8ke2lkfS9yZWRhY3RlZC1hdWRpb2ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcmVkYWN0ZWQgYXVkaW8gZmlsZSBvZiBhIHRyYW5zY3JpcHQuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkZW50aWZpZXIgb2YgdGhlIHRyYW5zY3JpcHQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZldGNoIEhUVFAgcmVzcG9uc2Ugb2YgdGhlIHJlZGFjdGVkIGF1ZGlvIGZpbGUuXG4gICAgICovXG4gICAgYXN5bmMgcmVkYWN0ZWRBdWRpb0ZpbGUoaWQpIHtcbiAgICAgICAgY29uc3QgeyByZWRhY3RlZF9hdWRpb191cmwsIHN0YXR1cyB9ID0gYXdhaXQgdGhpcy5yZWRhY3RlZEF1ZGlvKGlkKTtcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gXCJyZWRhY3RlZF9hdWRpb19yZWFkeVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZGFjdGVkIGF1ZGlvIHN0YXR1cyBpcyAke3N0YXR1c31gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlZGFjdGVkX2F1ZGlvX3VybCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHJlZGFjdGVkIGF1ZGlvOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFycmF5QnVmZmVyOiByZXNwb25zZS5hcnJheUJ1ZmZlci5iaW5kKHJlc3BvbnNlKSxcbiAgICAgICAgICAgIGJsb2I6IHJlc3BvbnNlLmJsb2IuYmluZChyZXNwb25zZSksXG4gICAgICAgICAgICBib2R5OiByZXNwb25zZS5ib2R5LFxuICAgICAgICAgICAgYm9keVVzZWQ6IHJlc3BvbnNlLmJvZHlVc2VkLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuY29uc3QgcmVhZEZpbGUgPSBhc3luYyAocGF0aCkgPT4gUmVhZGFibGUudG9XZWIoY3JlYXRlUmVhZFN0cmVhbShwYXRoKSk7XG5cbmNsYXNzIEZpbGVTZXJ2aWNlIGV4dGVuZHMgQmFzZVNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIFVwbG9hZCBhIGxvY2FsIGZpbGUgdG8gQXNzZW1ibHlBSS5cbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgbG9jYWwgZmlsZSBwYXRoIHRvIHVwbG9hZCwgb3IgYSBzdHJlYW0gb3IgYnVmZmVyIG9mIHRoZSBmaWxlIHRvIHVwbG9hZC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdXBsb2FkZWQgZmlsZSBVUkwuXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkKGlucHV0KSB7XG4gICAgICAgIGxldCBmaWxlRGF0YTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGlucHV0LnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgICAgICAgICAgICAgIGZpbGVEYXRhID0gZGF0YVVybFRvQmxvYihpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlRGF0YSA9IGF3YWl0IHJlYWRGaWxlKGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaWxlRGF0YSA9IGlucHV0O1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5mZXRjaEpzb24oXCIvdjIvdXBsb2FkXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBib2R5OiBmaWxlRGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cGxleDogXCJoYWxmXCIsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YS51cGxvYWRfdXJsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRhdGFVcmxUb0Jsb2IoZGF0YVVybCkge1xuICAgIGNvbnN0IGFyciA9IGRhdGFVcmwuc3BsaXQoXCIsXCIpO1xuICAgIGNvbnN0IG1pbWUgPSBhcnJbMF0ubWF0Y2goLzooLio/KTsvKVsxXTtcbiAgICBjb25zdCBic3RyID0gYXRvYihhcnJbMV0pO1xuICAgIGxldCBuID0gYnN0ci5sZW5ndGg7XG4gICAgY29uc3QgdThhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgIHU4YXJyW25dID0gYnN0ci5jaGFyQ29kZUF0KG4pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJsb2IoW3U4YXJyXSwgeyB0eXBlOiBtaW1lIH0pO1xufVxuXG5jb25zdCBkZWZhdWx0QmFzZVVybCA9IFwiaHR0cHM6Ly9hcGkuYXNzZW1ibHlhaS5jb21cIjtcbmNsYXNzIEFzc2VtYmx5QUkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBBc3NlbWJseUFJIGNsaWVudC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBzZXJ2aWNlLCBpbmNsdWRpbmcgdGhlIEFQSSBrZXkgYW5kIGJhc2UgVVJMLCBpZiBhbnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcy5iYXNlVXJsID0gcGFyYW1zLmJhc2VVcmwgfHwgZGVmYXVsdEJhc2VVcmw7XG4gICAgICAgIGlmIChwYXJhbXMuYmFzZVVybCAmJiBwYXJhbXMuYmFzZVVybC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIHBhcmFtcy5iYXNlVXJsID0gcGFyYW1zLmJhc2VVcmwuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsZXMgPSBuZXcgRmlsZVNlcnZpY2UocGFyYW1zKTtcbiAgICAgICAgdGhpcy50cmFuc2NyaXB0cyA9IG5ldyBUcmFuc2NyaXB0U2VydmljZShwYXJhbXMsIHRoaXMuZmlsZXMpO1xuICAgICAgICB0aGlzLmxlbXVyID0gbmV3IExlbXVyU2VydmljZShwYXJhbXMpO1xuICAgICAgICB0aGlzLnJlYWx0aW1lID0gbmV3IFJlYWx0aW1lVHJhbnNjcmliZXJGYWN0b3J5KHBhcmFtcyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBc3NlbWJseUFJLCBGaWxlU2VydmljZSwgTGVtdXJTZXJ2aWNlLCBSZWFsdGltZVNlcnZpY2UsIFJlYWx0aW1lU2VydmljZUZhY3RvcnksIFJlYWx0aW1lVHJhbnNjcmliZXIsIFJlYWx0aW1lVHJhbnNjcmliZXJGYWN0b3J5LCBUcmFuc2NyaXB0U2VydmljZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/assemblyai/dist/node.mjs\n");

/***/ })

};
;